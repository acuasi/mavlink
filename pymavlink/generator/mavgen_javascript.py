#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a python implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''

import sys, textwrap, os
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(outf, """
/*
MAVLink protocol implementation for node.js (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

//org: import struct, array, mavutil, time, json
var jspack = require("../lib/node-jspack-master/jspack.js"),
    mavutil = require("../lib/mavutil.js");

//org: WIRE_PROTOCOL_VERSION = "${WIRE_PROTOCOL_VERSION}"
var mavlink = {};
mavlink.WIRE_PROTOCOL_VERSION = "${WIRE_PROTOCOL_VERSION}";

//org: # some base types from mavlink_types.h
mavlink.MAVLINK_TYPE_CHAR     = 0
mavlink.MAVLINK_TYPE_UINT8_T  = 1
mavlink.MAVLINK_TYPE_INT8_T   = 2
mavlink.MAVLINK_TYPE_UINT16_T = 3
mavlink.MAVLINK_TYPE_INT16_T  = 4
mavlink.MAVLINK_TYPE_UINT32_T = 5
mavlink.MAVLINK_TYPE_INT32_T  = 6
mavlink.MAVLINK_TYPE_UINT64_T = 7
mavlink.MAVLINK_TYPE_INT64_T  = 8
mavlink.MAVLINK_TYPE_FLOAT    = 9
mavlink.MAVLINK_TYPE_DOUBLE   = 10

// Class definition: MAVLink_header
MAVLink_header = function(msgId, mlen, seq, srcSystem, srcComponent) {

        this.mlen = ( typeof mlen === 'undefined' ) ? 0 : mlen;
        this.seq = ( typeof seq === 'undefined' ) ? 0 : seq;
        this.srcSystem = ( typeof srcSystem === 'undefined' ) ? 0 : srcSystem;
        this.srcComponent = ( typeof srcComponent === 'undefined' ) ? 0 : srcComponent;
        this.msgId = msgId

}

MAVLink_header.prototype.pack = function() {
    return jspack.pack('BBBBBB', ${PROTOCOL_MARKER}, this.memlen, this.seq, this.srcSystem, this.srcComponent, this.msgId);
}

// Class definition: MAVLink_message
MAVLink_message = function(msgId, name) {
    this.header = new MAVLink_header(msgId);
}

/* Org: not sure what to do with this one yet.  Intent is to ensure it's a string,
but not sure why.  Perhaps not needed.

    def get_msgbuf(self):
        if isinstance(self._msgbuf, str):
            return self._msgbuf
        return self._msgbuf.tostring()
*/

MAVLink_message.prototype.pack = function(mav, crc_extra, payload) {
    this.payload = payload;
    this.header = new MAVLink_header(this.header.msgId, payload.length(), mav.seq, mav.srcSystem, mav.srcComponent);
    this.msgbuf = this.header.pack() + payload;

    // May need to slice msgbuf, not sure yet
    crc = mavutil.x25crc(this.msgbuf);

    this.crc = crc.crc;
    this.msgbuf += jspack.pack('<H', this.crc);
    return this.msgbuf;
}

""", {'FILELIST' : ",".join(args),
      'PROTOCOL_MARKER' : xml.protocol_marker,
      'crc_extra' : xml.crc_extra,
      'WIRE_PROTOCOL_VERSION' : xml.wire_protocol_version })

def generate_enums(outf, enums):
    print("Generating enums")
    outf.write("\n// enums\n")
    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="                        // ")
    for e in enums:
        outf.write("\n// %s\n" % e.name)
        for entry in e.entry:
            outf.write("mavlink.%s = %u // %s\n" % (entry.name, entry.value, wrapper.fill(entry.description)))

def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("\n// message IDs\n")
    outf.write("mavlink.MAVLINK_MSG_ID_BAD_DATA = -1\n")
    for m in msgs:
        outf.write("mavlink.MAVLINK_MSG_ID_%s = %u\n" % (m.name.upper(), m.id))

def generate_classes(outf, msgs):
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper(initial_indent="        ", subsequent_indent="        ")
    for m in msgs:
        outf.write("""
/*
%s
*/
MAVLink_%s_message = function(MAVLink_message
        """ % (wrapper.fill(m.description.strip()), m.name.lower()))
        if len(m.fields) != 0:
                outf.write(", " + ", ".join(m.fieldnames))
        outf.write(") {\n")
        outf.write("                MAVLink_message(this, MAVLINK_MSG_ID_%s, '%s');\n" % (m.name.upper(), m.name.upper()))
        if len(m.fieldnames) != 0:
                outf.write("                this.fieldnames = ['%s'];\n" % "', '".join(m.fieldnames))
        for f in m.fields:
                outf.write("                this.%s = %s;\n" % (f.name, f.name))
        outf.write("\n}")
        outf.write("""
MAVLink_%s_message.prototype.pack = function(mav) {
                return MAVLink_message.pack(mav, %u, jspack.pack('%s'""" % (m.name.lower(), m.crc_extra, m.fmtstr))
        if len(m.fields) != 0:
                outf.write(", this." + ", this.".join(m.ordered_fieldnames))
        outf.write("))}\n")

def mavfmt(field):
    '''work out the struct format for a type'''
    map = {
        'float'    : 'f',
        'double'   : 'd',
        'char'     : 'c',
        'int8_t'   : 'b',
        'uint8_t'  : 'B',
        'uint8_t_mavlink_version'  : 'B',
        'int16_t'  : 'h',
        'uint16_t' : 'H',
        'int32_t'  : 'i',
        'uint32_t' : 'I',
        'int64_t'  : 'q',
        'uint64_t' : 'Q',
        }

    if field.array_length:
        if field.type in ['char', 'int8_t', 'uint8_t']:
            return str(field.array_length)+'s'
        return str(field.array_length)+map[field.type]
    return map[field.type]

def generate_mavlink_class(outf, msgs, xml):
    print("Generating MAVLink class")

    outf.write("\n\nmavlink.mavlink_map = {\n");
    for m in msgs:
        outf.write("        MAVLINK_MSG_ID_%s : { fmt: '%s', type: MAVLink_%s_message, order_map: %s, crc_extra: %u },\n" % (
            m.name.upper(), m.fmtstr, m.name.lower(), m.order_map, m.crc_extra))
    outf.write("}\n\n")
    
    t.write(outf, """

/** org: This is only used in one place, I think, and should be inlined there.  Leaving it here as remenant until
that coding is done.
class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]
*/

/** org: again, unsure how to render this in the JS context.  It's a somewhat structured
representation of a bad data packet, I think intended for logging/debugging.

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
*/

/* MAVLink protocol handling class */
MAVLink = function(file, srcSystem, srcComponent) {

    this.seq = 0;
    this.file = file;
    this.srcSystem = (typeof srcSystem === 'undefined') ? 0 : srcSystem;
    this.srcComponent =  (typeof srcComponent === 'undefined') ? 0 : srcComponent;
    this.callback = None;
    this.callback_args = None;
    this.callback_kwargs = None;
    
    // org: this.buf = array.array('B');  -- intent is to have an array of unsigned chars.
    // Reference: https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays/ArrayBufferView#Typed_array_subclasses
    // Not sure what is needed for this, yet.
    this.buf = new Uint8Array();

    this.expected_length = 6;
    this.have_prefix_error = False;
    this.robust_parsing = False;
    this.protocol_marker = ${protocol_marker};
    this.little_endian = ${little_endian};
    this.crc_extra = ${crc_extra};
    this.sort_fields = ${sort_fields};
    this.total_packets_sent = 0;
    this.total_bytes_sent = 0;
    this.total_packets_received = 0;
    this.total_bytes_received = 0;
    this.total_receive_errors = 0;
    // org: this.startup_time = time.time(); -- not sure how this is used
    this.startup_time = Date.now();
    
}            

/** org: Because we're in a fully event-driven context, I don't think this is needed.
        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs
*/

/* Send a MAVLink message */
MAVLink.prototype.send = function(mavmsg) {
        buf = mavmsg.pack(this);
        this.file.write(buf);
        this.seq = (this.seq + 1) % 255;
        this.total_packets_sent +=1;
        this.total_bytes_sent += buf.length();
}

// return number of bytes needed for next parsing stage
MAVLink.prototype.bytes_needed = function() {
    ret = this.expected_length - this.buf.length();
    return ( ret <= 0 ) ? 1 : ret;
}

// input some data bytes, possibly returning a new message
MAVLink.prototype.parse_char = function(c) {

    this.buf.push(c);    
    this.total_bytes_received += c.length();

    if( this.buf.length() >= 1 && this.buf[0] != ${protocol_marker} ) {

            var magic = this.buf[0];
            this.buf = this.buf.slice(1);

            if( this.robust_parsing ) {
                var m = new MAVLink_bad_data( String.charCodeAt(magic), "Bad prefix" );
                
                // Skipping callback implementation found in original code (mavgen_python.py@295)
                
                this.expected_length = 6;
                this.total_receive_errors +=1;
                return m;
            }

            if( this.have_prefix_error ) {
                return null;
            }

            this.have_prefix_error = true;
            this.total_receive_errors += 1;
            throw new Error("invalid MAVLink prefix '"+ magic +"'");
    }
    this.have_prefix_error = false;

    if( this.buf.length() >= 2 ) {
        var unpacked = jspack.unpack('BB', this.buf.slice(0, 2));
        magic = unpacked[0];
        this.expected_length = unpacked[1] + 8;
    }

    if( this.expected_length >= 8 && this.buf.length() >= this.expected_length ) {
        var mbuf = this.buf.slice(0, this.expected_length);
        this.buf = this.buf.slice(this.expected_length);
        this.expected_length = 6;

        if( this.robust_parsing ) {

            try {
                var m = this.decode(mbuf);
                this.total_packets_received += 1;
            }
            catch(e) {
                var m = MAVLink_bad_data(mbuf, e.message);
                this.total_receive_errors += 1;
            }

        } else {
            var m = this.decode(mbuf);
            this.total_packets_received += 1;
        }

        // Skipping callback implementation found in original code (mavgen_python.py@323)

        return m;
    }
    return null;
}

// input some data bytes, possibly returning an array of new messages
MAVLink.prototype.parse_buffer = function(s) {
    var m = this.parse_char(s);

    if ( null === m ) {
        return null;
    }
    
    var ret = [m];
    while(true) {
        m = this.parse_char("");
        if ( null === m ) {
            return ret;
        }
        ret.push(m);
    }
    return ret;

}

/* decode a buffer as a MAVLink message */
MAVLink.prototype.decode = function(msgbuf) {

        // decode the header
        try {
            var unpacked = jspack.unpack('cBBBBB', msgbuf.slice(0, 6));
            magic = unpacked[0];
            mlen = unpacked[1];
            seq = unpacked[2];
            srcSystem = unpacked[3];
            srcComponent = unpacked[4];
            msgId = unpacked[5];
        }
        catch(e) {
            throw new Error('Unable to unpack MAVLink header: ' + e.message);
        }

        if (magic.charCodeAt(0) != ${protocol_marker}) {
            throw new Error("invalid MAVLink prefix '"+magic+"'");
        }

        if( mlen != msgbuf.length() - 8 ) {
            throw new Error("invalid MAVLink message length.  Got " + (msgbuf.length() - 8) + " expected " + mlen + ", msgId=" + msgId);
        }

        if( false === _.has(mavlink.mavlink_map, msgId) ) {
            throw new Error("unknown MAVLink message ID " + msgId);
        }

        // decode the payload
        // refs: (fmt, type, order_map, crc_extra) = mavlink_map[msgId]
        var decoder = mavlink_map[msgId];

        // decode the checksum
        try {
            var crc = jspack.unpack('<H', msgbuf.slice(-2));
        }   
        catch (e) {
            throw new Error("Unable to unpack MAVLink CRC: " + e.message);
        }

        var crc2 = mavutil.x25crc(msgbuf.slice(1, -2));

        if (${crc_extra}) {
            // using CRC extra 
            crc2.accumulate(String.charCodeAt(decoder.crc_extra));
        }

        if ( crc != crc2.crc ) {
            throw new Error('invalid MAVLink CRC in msgID ' +msgId+ ' 0x' +crc+ ' should be 0x'+crc2.crc);
        }

        try {
            var t = jspack.unpack(decoder.fmt, msgbuf.slice(6, -2));
        }
        catch (e) {
            throw new Error('Unable to unpack MAVLink payload type='+decoder.type+' fmt='+decoder.fmt+' payloadLength='+ msgbuf.slice(6, -2).length() +': '+ e.message);
        }

        /* org: these parts, I need to see what they're doing before translating.
        Perhaps are syntatic sugar.

        tlist = list(t) ?? does what?
        
        # handle sorted fields
        if (${sort_fields}) {
            t = tlist[:]
            for i in range(0, len(tlist)):
                tlist[i] = t[order_map[i]]
        }

        # terminate any strings
        for i in range(0, len(tlist)):
            if isinstance(tlist[i], str):
                tlist[i] = MAVString(tlist[i])
        t = tuple(tlist)
        */

        // construct the message object
        try {
            // Unlikely to work.  Will need to build factory.
            var m = new decoder.type;
        }
        catch (e) {
            throw new Error('Unable to instantiate MAVLink message of type '+decoder.type+' : ' + e.message);
        }
        m._msgbuf = msgbuf;
        m._payload = msgbuf.slice(6, -2);
        m._crc = crc;
        m._header = new MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent);
        return m;
}
""", xml)

def generate_methods(outf, msgs):
    print("Generating methods")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            ret += "                %-18s        : %s (%s)\n" % (f.name, f.description.strip(), f.type)
        return ret

    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="\t")

    for m in msgs:
        comment = "%s\n\n%s" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))

        selffieldnames = 'self, '
        for f in m.fields:
            # if f.omit_arg:
            #    selffieldnames += '%s=%s, ' % (f.name, f.const_value)
            #else:
            # -- Omitting the code above because it is rarely used (only once?) and would need some special handling
            # in javascript.  Specifically, inside the method definition, it needs to check for a value then assign
            # a default.
            selffieldnames += '%s, ' % f.name
        selffieldnames = selffieldnames[:-2]

        sub = {'NAMELOWER'      : m.name.lower(),
               'SELFFIELDNAMES' : selffieldnames,
               'COMMENT'        : comment,
               'FIELDNAMES'     : ", ".join(m.fieldnames)}

        t.write(outf, """
/* 
${COMMENT}
*/
MAVLink.prototype.${NAMELOWER}_encode = function(${SELFFIELDNAMES}) {
    var msg = new MAVLink_${NAMELOWER}_message(${FIELDNAMES});
    msg.pack(this);
    return msg;
}
""", sub)

        t.write(outf, """
MAVLink.prototype.${NAMELOWER}_send = function(${SELFFIELDNAMES}) {
    return this.send(this.${NAMELOWER}_encode(${FIELDNAMES}));
}

""", sub)

def generate_footer(outf):
    t.write(outf, """

// Expose this code as a module
exports.mavlink = mavlink;

""")

def generate(basename, xml):
    '''generate complete javascript implementation'''

    print basename;
    if basename.endswith('.js'):
        filename = basename
    else:
        filename = basename + '.js'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        if xml[0].little_endian:
            m.fmtstr = '<'
        else:
            m.fmtstr = '>'
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
        m.order_map = [ 0 ] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, filelist, xml[0])
    generate_enums(outf, enums)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs)
    generate_mavlink_class(outf, msgs, xml[0])
    generate_methods(outf, msgs)
    generate_footer(outf)
    outf.close()
    print("Generated %s OK" % filename)
